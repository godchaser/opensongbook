package org.duckdns.valci.opensongbook.data;

import java.io.File;
import java.io.IOException;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.vaadin.data.util.sqlcontainer.connection.JDBCConnectionPool;
import com.vaadin.data.util.sqlcontainer.connection.SimpleJDBCConnectionPool;
import com.vaadin.server.FileResource;
import com.vaadin.server.VaadinService;

public class DatabaseHelper implements Serializable {
    /**
     * 
     */
    private static final long serialVersionUID = 1L;

    static final Logger LOG = LoggerFactory.getLogger(DatabaseHelper.class);

    private static DatabaseHelper instance;

    private String basepath;
    private FileResource dbFile;

    private JDBCConnectionPool connectionPool = null;

    // ID, SONGTITLE, SONGLYRICS, SONGAUTHOR, MODIFIEDBY, MODIFIEDDATE
    // TODO: implement field validators for db constraints - varchar lenght
    //@formatter:off
    private String dropTableCMD = "DROP TABLE "+ SongSQLContainer.TABLE;
    private String createTableCMD = "CREATE TABLE IF NOT EXISTS " + SongSQLContainer.TABLE + " ("
            + "ID INTEGER GENERATED BY DEFAULT AS IDENTITY, "
            + "songTitle varchar(32), "
            + "songLyrics longvarchar, "
            + "songAuthor varchar(32), "
            + "modifiedBy varchar(32), "
            + "modifiedDate varchar(32), "
            + "version INTEGER DEFAULT 0 NOT NULL, "
            + "primary key (ID))";  
    private String insertSampleDataCMD = 
              "INSERT INTO " + SongSQLContainer.TABLE + " VALUES(NULL,'Naslov neke pjesme', 'Sadrzaj neke pjesme', 'Samuel', '', '06/11/2014 11:25',0);";
            //+ "INSERT INTO " + SongSQLContainer.TABLE + " VALUES(NULL,'BUG', 'ONGOING', 'NORMAL', 'Sample ongoing bug ticket', 'Samuel', '06/11/2014 12:25','Samuel',0);"
            //+ "INSERT INTO " + SongSQLContainer.TABLE + " VALUES(NULL,'BUG', 'ONGOING', 'HIGH', 'Sample ongoing high prio bug ticket', 'Samuel', '06/11/2014 14:25','Samuel',0);"
            //+ "INSERT INTO " + SongSQLContainer.TABLE + " VALUES(NULL,'FEATURE', 'OPEN', 'LOW', 'Sample open low prio feature ticket', 'Samuel', '06/11/2014 15:25','Samuel',0);"
            //+ "INSERT INTO " + SongSQLContainer.TABLE + " VALUES(NULL,'FEATURE', 'CLOSED', 'NORMAL', 'Sample closed medium prio feature ticket', 'Samuel', '06/11/2014 15:26','Samuel',0);";
    private String testTableCMD = "SELECT * FROM INFORMATION_SCHEMA.SYSTEM_TABLES where TABLE_TYPE='TABLE'";
    private String testTableDataCMD = "SELECT * FROM " + SongSQLContainer.TABLE;
    private String deleteAllDataCMD = "delete from " + SongSQLContainer.TABLE;

    //@formatter:on

    private DatabaseHelper(boolean deployment) {
        if (deployment) {
            basepath = VaadinService.getCurrent().getBaseDirectory().getAbsolutePath();
            dbFile = new FileResource(new File(basepath + "/WEB-INF/resources/" + SongSQLContainer.TABLE + ".sql"));
        } else {
            basepath = "WebContent//WEB-INF//resources//" + SongSQLContainer.TABLE + ".sql";
        }
        initConnectionPool();
        initDatabase();
        // fillTestData();
    }

    public void selectAllData() {
        LOG.trace("Selecting data");
        executeSQLQuerry(testTableDataCMD);
    }

    public String executeCustomQuerry(String customQuerry) {
        LOG.trace("Executing custom querry: " + customQuerry);
        String res = executeSQLQuerry(customQuerry);
        return res;
    }

    public static DatabaseHelper getInstance() {
        if (instance == null) {
            LOG.trace("Instantiating DatabaseHelper");
            instance = new DatabaseHelper(true);
        }
        LOG.trace("Returning already instantiated DatabaseHelper");
        return instance;
    }

    public void fillTestData() {
        LOG.trace("Deleting all data");
        executeSQLCommand(deleteAllDataCMD);
        LOG.trace("Loading sample data");
        executeSQLCommand(insertSampleDataCMD);
        LOG.trace("Selecting data");
        executeSQLQuerry(testTableDataCMD);
    }

    private JDBCConnectionPool initConnectionPool() {
        try {
            String dbPath;
            if (dbFile != null) {
                dbPath = dbFile.getSourceFile().getCanonicalPath();
            } else {
                dbPath = basepath;
            }
            LOG.trace("Creating Connection Pool " + dbPath);
            // connectionPool = new SimpleJDBCConnectionPool("org.sqlite.JDBC",
            // "jdbc:sqlite:" + dbPath, "", "", 2, 5);
            // connectionPool = new
            // SimpleJDBCConnectionPool("org.hsqldb.jdbc.JDBCDriver",
            // "jdbc:hsqldb:mem:sqlcontainer" + dbPath, "", "", 2, 5);
            connectionPool = new SimpleJDBCConnectionPool("org.hsqldb.jdbc.JDBCDriver", "jdbc:hsqldb:file:" + dbPath,
                    "", "", 2, 20);
        } catch (SQLException e) {
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return connectionPool;
    }

    public void initDatabase() {
        LOG.trace("Initializing db");
        executeSQLCommand(createTableCMD);
    }

    private void executeSQLCommand(String... commands) {
        try {
            Connection conn = connectionPool.reserveConnection();
            Statement statement = conn.createStatement();
            for (String command : commands) {
                LOG.trace("sqlcmd: " + command);
                statement.execute(command);
            }
            statement.close();
            conn.commit();
            connectionPool.releaseConnection(conn);
        } catch (SQLException e) {
            LOG.trace("ExecuteSQLCommand failed");
            e.printStackTrace();
        }
    }

    static class PrintColumnTypes {

        public static void printColTypes(ResultSetMetaData rsmd) throws SQLException {
            int columns = rsmd.getColumnCount();
            for (int i = 1; i <= columns; i++) {
                int jdbcType = rsmd.getColumnType(i);
                String name = rsmd.getColumnTypeName(i);
                LOG.trace("Column " + i + " is JDBC type " + jdbcType);
                LOG.trace(", which the DBMS calls " + name);
            }
        }
    }

    private String executeSQLQuerry(String... commands) {
        StringBuilder resultBuffer = new StringBuilder();
        try {
            Connection conn = connectionPool.reserveConnection();
            Statement statement = conn.createStatement();
            for (String command : commands) {
                ResultSet rs = statement.executeQuery(command);
                ResultSetMetaData rsmd = rs.getMetaData();
                PrintColumnTypes.printColTypes(rsmd);
                int numberOfColumns = rsmd.getColumnCount();
                LOG.trace("COLUMN NAMES");
                for (int i = 1; i <= numberOfColumns; i++) {
                    if (i > 1) {
                        // LOG.trace(",  ");
                        String columnName = rsmd.getColumnName(i);
                        LOG.trace(columnName);
                    }
                }

                while (rs.next()) {
                    resultBuffer.append(rs.getString(1));
                    resultBuffer.append("\n");

                    // this is for multiple columns
                    for (int i = 1; i <= numberOfColumns; i++) {
                        if (i > 1) {
                            // LOG.trace(",  ");
                            String columnValue = rs.getString(i);
                            resultBuffer.append(columnValue);
                            // LOG.trace(columnValue);
                        }
                    }

                    LOG.trace("");
                }
                rs.close();
            }
            statement.close();
            conn.commit();
            connectionPool.releaseConnection(conn);
        } catch (SQLException e) {
            LOG.trace("ExecuteSQLCommand failed");
            e.printStackTrace();
        }
        return resultBuffer.toString();
    }

    public JDBCConnectionPool getConnectionPool() {
        return connectionPool;
    }

    public void releaseConnections() {
        LOG.trace("Connection pool destroy connections");
        connectionPool.destroy();
    }

    public static void main(String[] args) {
        DatabaseHelper dh = new DatabaseHelper(false);
    }
}
